
#[derive(Debug, Clone, Copy)]
struct RegistradoresRISC {
    // Registradores principais conforme especificação RISC-V
    x0: u32,   // zero - sempre zero
    x1: u32,   // ra - return address
    x2: u32,   // sp - stack pointer
    x3: u32,   // gp - global pointer
    x4: u32,   // tp - thread pointer
    x5: u32,   // t0 - temporário 0
    x6: u32,   // t1 - temporário 1
    x7: u32,   // t2 - temporário 2
    x8: u32,   // s0/fp - saved/frame pointer
    x9: u32,   // s1 - saved 1
    x10: u32,  // a0 - argumento/retorno 0
    x11: u32,  // a1 - argumento/retorno 1
    x12: u32,  // a2 - argumento 2
    x13: u32,  // a3 - argumento 3
    x14: u32,  // a4 - argumento 4
    x15: u32,  // a5 - argumento 5
    x16: u32,  // a6 - argumento 6
    x17: u32,  // a7 - argumento 7
    x18: u32,  // s2 - saved 2
    x19: u32,  // s3 - saved 3
    x20: u32,  // s4 - saved 4
    x21: u32,  // s5 - saved 5
    x22: u32,  // s6 - saved 6
    x23: u32,  // s7 - saved 7
    x24: u32,  // s8 - saved 8
    x25: u32,  // s9 - saved 9
    x26: u32,  // s10 - saved 10
    x27: u32,  // s11 - saved 11
    x28: u32,  // t3 - temporário 3
    x29: u32,  // t4 - temporário 4
    x30: u32,  // t5 - temporário 5
    x31: u32,  // t6 - temporário 6
    pc: u32,   // Program Counter
}

impl RegistradoresRISC {
    fn new() -> Self {
        RegistradoresRISC {
            x0: 0,
            x1: 0,
            x2: 0,
            x3: 0,
            x4: 0,
            x5: 0,
            x6: 0,
            x7: 0,
            x8: 0,
            x9: 0,
            x10: 0,
            x11: 0,
            x12: 0,
            x13: 0,
            x14: 0,
            x15: 0,
            x16: 0,
            x17: 0,
            x18: 0,
            x19: 0,
            x20: 0,
            x21: 0,
            x22: 0,
            x23: 0,
            x24: 0,
            x25: 0,
            x26: 0,
            x27: 0,
            x28: 0,
            x29: 0,
            x30: 0,
            x31: 0,
            pc: 0,
        }
    }

    fn ler(&self, numero_reg: usize) -> u32 {
        match numero_reg {
            0 => self.x0,
            1 => self.x1,
            2 => self.x2,
            3 => self.x3,
            4 => self.x4,
            5 => self.x5,
            6 => self.x6,
            7 => self.x7,
            8 => self.x8,
            9 => self.x9,
            10 => self.x10,
            11 => self.x11,
            12 => self.x12,
            13 => self.x13,
            14 => self.x14,
            15 => self.x15,
            16 => self.x16,
            17 => self.x17,
            18 => self.x18,
            19 => self.x19,
            20 => self.x20,
            21 => self.x21,
            22 => self.x22,
            23 => self.x23,
            24 => self.x24,
            25 => self.x25,
            26 => self.x26,
            27 => self.x27,
            28 => self.x28,
            29 => self.x29,
            30 => self.x30,
            31 => self.x31,
            _ => 0,
        }
    }

    fn escrever(&mut self, numero_reg: usize, valor: u32) {
        if numero_reg != 0 {
            match numero_reg {
                1 => self.x1 = valor,
                2 => self.x2 = valor,
                3 => self.x3 = valor,
                4 => self.x4 = valor,
                5 => self.x5 = valor,
                6 => self.x6 = valor,
                7 => self.x7 = valor,
                8 => self.x8 = valor,
                9 => self.x9 = valor,
                10 => self.x10 = valor,
                11 => self.x11 = valor,
                12 => self.x12 = valor,
                13 => self.x13 = valor,
                14 => self.x14 = valor,
                15 => self.x15 = valor,
                16 => self.x16 = valor,
                17 => self.x17 = valor,
                18 => self.x18 = valor,
                19 => self.x19 = valor,
                20 => self.x20 = valor,
                21 => self.x21 = valor,
                22 => self.x22 = valor,
                23 => self.x23 = valor,
                24 => self.x24 = valor,
                25 => self.x25 = valor,
                26 => self.x26 = valor,
                27 => self.x27 = valor,
                28 => self.x28 = valor,
                29 => self.x29 = valor,
                30 => self.x30 = valor,
                31 => self.x31 = valor,
                _ => {},
            }
        }
    }

    fn mostrar_estado(&self) {
        println!("\n=== ESTADO DOS REGISTRADORES RISC-V ===");
        println!("PC: 0x{:08X}", self.pc);
        println!("x0 (zero): 0x{:08X} ({})", self.x0, self.x0);
        println!("x1 (ra):   0x{:08X} ({})", self.x1, self.x1);
        println!("x5 (t0):   0x{:08X} ({}) - bin: {:b}", self.x5, self.x5, self.x5);
        println!("x6 (t1):   0x{:08X} ({}) - bin: {:b}", self.x6, self.x6, self.x6);
        println!("x7 (t2):   0x{:08X} ({}) - bin: {:b}", self.x7, self.x7, self.x7);
        println!("x9 (s1):   0x{:08X} ({}) - bin: {:b}", self.x9, self.x9, self.x9);
        println!("x28 (t3):  0x{:08X} ({}) - bin: {:b}", self.x28, self.x28, self.x28);
        println!("x29 (t4):  0x{:08X} ({}) - bin: {:b}", self.x29, self.x29, self.x29);
        println!("x30 (t5):  0x{:08X} ({}) - bin: {:b}", self.x30, self.x30, self.x30);
        println!("x31 (t6):  0x{:08X} ({}) - bin: {:b}", self.x31, self.x31, self.x31);
    }
}

// =============================================
// FUNÇÕES DA ISA RISC-V RV32I
// =============================================

// =============================================
// INSTRUÇÕES DE SHIFT (SHIFT)
// =============================================

fn instrucao_sll(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, rs2: usize) {
    let valor1 = regs.ler(rs1);
    let valor2 = regs.ler(rs2);
    let shamt = valor2 & 0x1F; // Apenas 5 bits menos significativos
    let resultado = valor1 << shamt;
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("SLL: x{} = x{} ({:b}) << {} = {:b}", 
             rd, rs1, valor1, shamt, resultado);
}

fn instrucao_slli(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, shamt: u32) {
    let valor1 = regs.ler(rs1);
    let resultado = valor1 << (shamt & 0x1F);
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("SLLI: x{} = x{} ({:b}) << {} = {:b}", 
             rd, rs1, valor1, shamt & 0x1F, resultado);
}

fn instrucao_srl(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, rs2: usize) {
    let valor1 = regs.ler(rs1);
    let valor2 = regs.ler(rs2);
    let shamt = valor2 & 0x1F;
    let resultado = valor1 >> shamt;
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("SRL: x{} = x{} ({:b}) >> {} = {:b}", 
             rd, rs1, valor1, shamt, resultado);
}

fn instrucao_srli(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, shamt: u32) {
    let valor1 = regs.ler(rs1);
    let resultado = valor1 >> (shamt & 0x1F);
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("SRLI: x{} = x{} ({:b}) >> {} = {:b}", 
             rd, rs1, valor1, shamt & 0x1F, resultado);
}

fn instrucao_sra(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, rs2: usize) {
    let valor1 = regs.ler(rs1) as i32;
    let valor2 = regs.ler(rs2);
    let shamt = (valor2 & 0x1F) as i32;
    let resultado = (valor1 >> shamt) as u32;
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("SRA: x{} = x{} ({}) >> {} = {}", 
             rd, rs1, valor1, shamt, resultado);
}

fn instrucao_srai(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, shamt: u32) {
    let valor1 = regs.ler(rs1) as i32;
    let resultado = (valor1 >> (shamt & 0x1F) as i32) as u32;
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("SRAI: x{} = x{} ({}) >> {} = {}", 
             rd, rs1, valor1, shamt & 0x1F, resultado);
}

// =============================================
// INSTRUÇÕES ARITMÉTICAS (ARITHMETIC)
// =============================================

fn instrucao_add(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, rs2: usize) {
    let valor1 = regs.ler(rs1);
    let valor2 = regs.ler(rs2);
    let resultado = valor1.wrapping_add(valor2);
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("ADD: x{} = x{} ({}) + x{} ({}) = {}", 
             rd, rs1, valor1, rs2, valor2, resultado);
}

fn instrucao_addi(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, imediato: i32) {
    let valor1 = regs.ler(rs1);
    let resultado = valor1.wrapping_add(imediato as u32);
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("ADDI: x{} = x{} ({}) + {} = {}", 
             rd, rs1, valor1, imediato, resultado);
}

fn instrucao_sub(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, rs2: usize) {
    let valor1 = regs.ler(rs1);
    let valor2 = regs.ler(rs2);
    let resultado = valor1.wrapping_sub(valor2);
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("SUB: x{} = x{} ({}) - x{} ({}) = {}", 
             rd, rs1, valor1, rs2, valor2, resultado);
}

fn instrucao_lui(regs: &mut RegistradoresRISC, rd: usize, imediato: i32) {
    let resultado = (imediato as u32) << 12;
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("LUI: x{} = {} << 12 = 0x{:08X}", 
             rd, imediato, resultado);
}

fn instrucao_auipc(regs: &mut RegistradoresRISC, rd: usize, imediato: i32) {
    let pc_atual = regs.pc;
    let resultado = pc_atual.wrapping_add((imediato as u32) << 12);
    regs.escrever(rd, resultado);
    regs.pc = pc_atual.wrapping_add(4);
    println!("AUIPC: x{} = PC (0x{:08X}) + ({} << 12) = 0x{:08X}", 
             rd, pc_atual, imediato, resultado);
}

// =============================================
// INSTRUÇÕES LÓGICAS (LOGIC)
// =============================================

fn instrucao_and(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, rs2: usize) {
    let valor1 = regs.ler(rs1);
    let valor2 = regs.ler(rs2);
    let resultado = valor1 & valor2;
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("AND: x{} = x{} ({:b}) & x{} ({:b}) = {:b}", 
             rd, rs1, valor1, rs2, valor2, resultado);
}

fn instrucao_andi(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, imediato: i32) {
    let valor1 = regs.ler(rs1);
    let resultado = valor1 & (imediato as u32);
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("ANDI: x{} = x{} ({:b}) & 0x{:08X} = {:b}", 
             rd, rs1, valor1, imediato as u32, resultado);
}

fn instrucao_or(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, rs2: usize) {
    let valor1 = regs.ler(rs1);
    let valor2 = regs.ler(rs2);
    let resultado = valor1 | valor2;
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("OR:  x{} = x{} ({:b}) | x{} ({:b}) = {:b}", 
             rd, rs1, valor1, rs2, valor2, resultado);
}

fn instrucao_ori(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, imediato: i32) {
    let valor1 = regs.ler(rs1);
    let resultado = valor1 | (imediato as u32);
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("ORI: x{} = x{} ({:b}) | 0x{:08X} = {:b}", 
             rd, rs1, valor1, imediato as u32, resultado);
}

fn instrucao_xor(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, rs2: usize) {
    let valor1 = regs.ler(rs1);
    let valor2 = regs.ler(rs2);
    let resultado = valor1 ^ valor2;
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("XOR: x{} = x{} ({:b}) ^ x{} ({:b}) = {:b}", 
             rd, rs1, valor1, rs2, valor2, resultado);
}

fn instrucao_xori(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, imediato: i32) {
    let valor1 = regs.ler(rs1);
    let resultado = valor1 ^ (imediato as u32);
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("XORI: x{} = x{} ({:b}) ^ 0x{:08X} = {:b}", 
             rd, rs1, valor1, imediato as u32, resultado);
}

// =============================================
// INSTRUÇÕES DE COMPARAÇÃO (COMPARISON)
// =============================================

fn instrucao_slt(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, rs2: usize) {
    let valor1 = regs.ler(rs1) as i32;
    let valor2 = regs.ler(rs2) as i32;
    let resultado = if valor1 < valor2 { 1 } else { 0 };
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("SLT: x{} = (x{} ({}) < x{} ({})) ? 1 : 0 = {}", 
             rd, rs1, valor1, rs2, valor2, resultado);
}

fn instrucao_slti(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, imediato: i32) {
    let valor1 = regs.ler(rs1) as i32;
    let resultado = if valor1 < imediato { 1 } else { 0 };
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("SLTI: x{} = (x{} ({}) < {}) ? 1 : 0 = {}", 
             rd, rs1, valor1, imediato, resultado);
}

fn instrucao_sltu(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, rs2: usize) {
    let valor1 = regs.ler(rs1);
    let valor2 = regs.ler(rs2);
    let resultado = if valor1 < valor2 { 1 } else { 0 };
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("SLTU: x{} = (x{} ({}) < x{} ({})) ? 1 : 0 = {}", 
             rd, rs1, valor1, rs2, valor2, resultado);
}

fn instrucao_sltiu(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, imediato: i32) {
    let valor1 = regs.ler(rs1);
    let imed_unsigned = (imediato as u32).wrapping_add(0);
    let resultado = if valor1 < imed_unsigned { 1 } else { 0 };
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("SLTIU: x{} = (x{} ({}) < {}) ? 1 : 0 = {}", 
             rd, rs1, valor1, imediato, resultado);
}

// =============================================
// INSTRUÇÕES DE DESVIO (BRANCH)
// =============================================

fn instrucao_beq(regs: &mut RegistradoresRISC, rs1: usize, rs2: usize, offset: i32) {
    let valor1 = regs.ler(rs1);
    let valor2 = regs.ler(rs2);
    if valor1 == valor2 {
        regs.pc = regs.pc.wrapping_add(offset as u32);
        println!("BEQ: x{} ({}) == x{} ({}) -> PC = PC + {} = 0x{:08X}", 
                 rs1, valor1, rs2, valor2, offset, regs.pc);
    } else {
        regs.pc = regs.pc.wrapping_add(4);
        println!("BEQ: x{} ({}) != x{} ({}) -> PC = PC + 4", 
                 rs1, valor1, rs2, valor2);
    }
}

fn instrucao_bne(regs: &mut RegistradoresRISC, rs1: usize, rs2: usize, offset: i32) {
    let valor1 = regs.ler(rs1);
    let valor2 = regs.ler(rs2);
    if valor1 != valor2 {
        regs.pc = regs.pc.wrapping_add(offset as u32);
        println!("BNE: x{} ({}) != x{} ({}) -> PC = PC + {} = 0x{:08X}", 
                 rs1, valor1, rs2, valor2, offset, regs.pc);
    } else {
        regs.pc = regs.pc.wrapping_add(4);
        println!("BNE: x{} ({}) == x{} ({}) -> PC = PC + 4", 
                 rs1, valor1, rs2, valor2);
    }
}

fn instrucao_blt(regs: &mut RegistradoresRISC, rs1: usize, rs2: usize, offset: i32) {
    let valor1 = regs.ler(rs1) as i32;
    let valor2 = regs.ler(rs2) as i32;
    if valor1 < valor2 {
        regs.pc = regs.pc.wrapping_add(offset as u32);
        println!("BLT: x{} ({}) < x{} ({}) -> PC = PC + {} = 0x{:08X}", 
                 rs1, valor1, rs2, valor2, offset, regs.pc);
    } else {
        regs.pc = regs.pc.wrapping_add(4);
        println!("BLT: x{} ({}) >= x{} ({}) -> PC = PC + 4", 
                 rs1, valor1, rs2, valor2);
    }
}

fn instrucao_bge(regs: &mut RegistradoresRISC, rs1: usize, rs2: usize, offset: i32) {
    let valor1 = regs.ler(rs1) as i32;
    let valor2 = regs.ler(rs2) as i32;
    if valor1 >= valor2 {
        regs.pc = regs.pc.wrapping_add(offset as u32);
        println!("BGE: x{} ({}) >= x{} ({}) -> PC = PC + {} = 0x{:08X}", 
                 rs1, valor1, rs2, valor2, offset, regs.pc);
    } else {
        regs.pc = regs.pc.wrapping_add(4);
        println!("BGE: x{} ({}) < x{} ({}) -> PC = PC + 4", 
                 rs1, valor1, rs2, valor2);
    }
}

fn instrucao_bltu(regs: &mut RegistradoresRISC, rs1: usize, rs2: usize, offset: i32) {
    let valor1 = regs.ler(rs1);
    let valor2 = regs.ler(rs2);
    if valor1 < valor2 {
        regs.pc = regs.pc.wrapping_add(offset as u32);
        println!("BLTU: x{} ({}) < x{} ({}) -> PC = PC + {} = 0x{:08X}", 
                 rs1, valor1, rs2, valor2, offset, regs.pc);
    } else {
        regs.pc = regs.pc.wrapping_add(4);
        println!("BLTU: x{} ({}) >= x{} ({}) -> PC = PC + 4", 
                 rs1, valor1, rs2, valor2);
    }
}

fn instrucao_bgeu(regs: &mut RegistradoresRISC, rs1: usize, rs2: usize, offset: i32) {
    let valor1 = regs.ler(rs1);
    let valor2 = regs.ler(rs2);
    if valor1 >= valor2 {
        regs.pc = regs.pc.wrapping_add(offset as u32);
        println!("BGEU: x{} ({}) >= x{} ({}) -> PC = PC + {} = 0x{:08X}", 
                 rs1, valor1, rs2, valor2, offset, regs.pc);
    } else {
        regs.pc = regs.pc.wrapping_add(4);
        println!("BGEU: x{} ({}) < x{} ({}) -> PC = PC + 4", 
                 rs1, valor1, rs2, valor2);
    }
}

// =============================================
// INSTRUÇÕES DE SALTO (JUMP)
// =============================================

fn instrucao_jal(regs: &mut RegistradoresRISC, rd: usize, offset: i32) {
    let pc_atual = regs.pc;
    regs.escrever(rd, pc_atual.wrapping_add(4));
    regs.pc = pc_atual.wrapping_add(offset as u32);
    println!("JAL: x{} = PC+4 (0x{:08X}), PC = PC + {} = 0x{:08X}", 
             rd, pc_atual.wrapping_add(4), offset, regs.pc);
}

fn instrucao_jalr(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, offset: i32) {
    let pc_atual = regs.pc;
    let base = regs.ler(rs1);
    regs.escrever(rd, pc_atual.wrapping_add(4));
    regs.pc = (base.wrapping_add(offset as u32)) & !1; // Clear LSB
    println!("JALR: x{} = PC+4 (0x{:08X}), PC = (x{} ({}) + {}) & ~1 = 0x{:08X}", 
             rd, pc_atual.wrapping_add(4), rs1, base, offset, regs.pc);
}

// =============================================
// INSTRUÇÕES DE CARGA (LOAD)
// =============================================

fn instrucao_lw(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, offset: i32, memoria: &MemoriaRAM) {
    let endereco_base = regs.ler(rs1);
    let endereco = endereco_base.wrapping_add(offset as u32);
    let valor = memoria.ler(endereco);
    regs.escrever(rd, valor);
    regs.pc = regs.pc.wrapping_add(4);
    println!("LW: x{} = Mem[0x{:08X}] = 0x{:08X} ({})", 
             rd, endereco, valor, valor);
}

fn instrucao_lh(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, offset: i32, memoria: &MemoriaRAM) {
    let endereco_base = regs.ler(rs1);
    let endereco = endereco_base.wrapping_add(offset as u32);
    let palavra = memoria.ler(endereco & !0x3); // Alinha para palavra
    let byte_offset = (endereco & 0x3) as usize * 8;
    let valor_sem_sinal = (palavra >> byte_offset) & 0xFFFF;
    let valor = (valor_sem_sinal as i16) as i32 as u32; // Extensão de sinal
    regs.escrever(rd, valor);
    regs.pc = regs.pc.wrapping_add(4);
    println!("LH: x{} = Mem[0x{:08X}] (com extensão de sinal) = 0x{:08X}", 
             rd, endereco, valor);
}

fn instrucao_lb(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, offset: i32, memoria: &MemoriaRAM) {
    let endereco_base = regs.ler(rs1);
    let endereco = endereco_base.wrapping_add(offset as u32);
    let palavra = memoria.ler(endereco & !0x3);
    let byte_offset = (endereco & 0x3) as usize * 8;
    let valor_sem_sinal = (palavra >> byte_offset) & 0xFF;
    let valor = (valor_sem_sinal as i8) as i32 as u32; // Extensão de sinal
    regs.escrever(rd, valor);
    regs.pc = regs.pc.wrapping_add(4);
    println!("LB: x{} = Mem[0x{:08X}] (com extensão de sinal) = 0x{:08X}", 
             rd, endereco, valor);
}

fn instrucao_lhu(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, offset: i32, memoria: &MemoriaRAM) {
    let endereco_base = regs.ler(rs1);
    let endereco = endereco_base.wrapping_add(offset as u32);
    let palavra = memoria.ler(endereco & !0x3);
    let byte_offset = (endereco & 0x3) as usize * 8;
    let valor = (palavra >> byte_offset) & 0xFFFF;
    regs.escrever(rd, valor);
    regs.pc = regs.pc.wrapping_add(4);
    println!("LHU: x{} = Mem[0x{:08X}] (sem extensão de sinal) = 0x{:08X}", 
             rd, endereco, valor);
}

fn instrucao_lbu(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, offset: i32, memoria: &MemoriaRAM) {
    let endereco_base = regs.ler(rs1);
    let endereco = endereco_base.wrapping_add(offset as u32);
    let palavra = memoria.ler(endereco & !0x3);
    let byte_offset = (endereco & 0x3) as usize * 8;
    let valor = (palavra >> byte_offset) & 0xFF;
    regs.escrever(rd, valor);
    regs.pc = regs.pc.wrapping_add(4);
    println!("LBU: x{} = Mem[0x{:08X}] (sem extensão de sinal) = 0x{:08X}", 
             rd, endereco, valor);
}

// =============================================
// INSTRUÇÕES DE ARMAZENAMENTO (STORE)
// =============================================

fn instrucao_sw(regs: &mut RegistradoresRISC, rs1: usize, rs2: usize, offset: i32, memoria: &mut MemoriaRAM) {
    let endereco_base = regs.ler(rs1);
    let endereco = endereco_base.wrapping_add(offset as u32);
    let valor = regs.ler(rs2);
    memoria.escrever(endereco, valor);
    regs.pc = regs.pc.wrapping_add(4);
    println!("SW: Mem[0x{:08X}] = x{} (0x{:08X})", 
             endereco, rs2, valor);
}

fn instrucao_sh(regs: &mut RegistradoresRISC, rs1: usize, rs2: usize, offset: i32, memoria: &mut MemoriaRAM) {
    let endereco_base = regs.ler(rs1);
    let endereco = endereco_base.wrapping_add(offset as u32);
    let valor = regs.ler(rs2) & 0xFFFF;
    
    // Lê a palavra atual
    let palavra_atual = memoria.ler(endereco & !0x3);
    let byte_offset = (endereco & 0x3) as usize * 8;
    
    // Limpa os 16 bits da posição
    let mascara_limpeza = !(0xFFFF << byte_offset);
    let palavra_limpa = palavra_atual & mascara_limpeza;
    
    // Insere os novos 16 bits
    let nova_palavra = palavra_limpa | (valor << byte_offset);
    
    memoria.escrever(endereco & !0x3, nova_palavra);
    regs.pc = regs.pc.wrapping_add(4);
    println!("SH: Mem[0x{:08X}] = x{}[15:0] (0x{:04X})", 
             endereco, rs2, valor);
}

fn instrucao_sb(regs: &mut RegistradoresRISC, rs1: usize, rs2: usize, offset: i32, memoria: &mut MemoriaRAM) {
    let endereco_base = regs.ler(rs1);
    let endereco = endereco_base.wrapping_add(offset as u32);
    let valor = regs.ler(rs2) & 0xFF;
    
    // Lê a palavra atual
    let palavra_atual = memoria.ler(endereco & !0x3);
    let byte_offset = (endereco & 0x3) as usize * 8;
    
    // Limpa o byte da posição
    let mascara_limpeza = !(0xFF << byte_offset);
    let palavra_limpa = palavra_atual & mascara_limpeza;
    
    // Insere o novo byte
    let nova_palavra = palavra_limpa | (valor << byte_offset);
    
    memoria.escrever(endereco & !0x3, nova_palavra);
    regs.pc = regs.pc.wrapping_add(4);
    println!("SB: Mem[0x{:08X}] = x{}[7:0] (0x{:02X})", 
             endereco, rs2, valor);
}

// =============================================
// INSTRUÇÕES DE SINCRONIZAÇÃO (SYNCHRONIZATION)
// =============================================

fn instrucao_fence(regs: &mut RegistradoresRISC) {
    // NOP no simulador
    regs.pc = regs.pc.wrapping_add(4);
    println!("FENCE: barreira de memória (ignorada no simulador)");
}

fn instrucao_fence_i(regs: &mut RegistradoresRISC) {
    // NOP no simulador
    regs.pc = regs.pc.wrapping_add(4);
    println!("FENCE.I: barreira de instruções (ignorada no simulador)");
}

// =============================================
// INSTRUÇÕES DE AMBIENTE (ENVIRONMENT)
// =============================================

fn instrucao_ecall(regs: &mut RegistradoresRISC) {
    regs.pc = regs.pc.wrapping_add(4);
    println!("ECALL: chamada de sistema (simulada)");
    // Em um simulador real, isso causaria uma exceção/trap
}

fn instrucao_ebreak(regs: &mut RegistradoresRISC) {
    regs.pc = regs.pc.wrapping_add(4);
    println!("EBREAK: ponto de depuração (simulado)");
    // Em um simulador real, isso pararia a execução para depuração
}

const EMPTY: u8 = 0xFF;

fn Barramento() {
    // Criar a memória PRIMEIRO
    let mut memoria = MemoriaRAM::new();
    
    // Escrever uma mensagem na VRAM
    let mensagem: &[u8; 8] = b"Bom dia!";
    for (i, &caractere) in mensagem.iter().enumerate() {
        memoria.escrever_vram_byte(0x80000 + i as u32 * 1, caractere);
    }
    
    // VISUALIZAÇÃO DA VRAM
    println!("\n=== VISUALIZAÇÃO DA VRAM ===");
    memoria.visualizar_vram(0x80000, 80, 6);
    
    // Agora executar CPU passando a memória
    CPU(&mut memoria);
}

fn CPU(memoria: &mut MemoriaRAM) {
       
    // Criar estrutura de registradores RISC-V
    let mut regs = RegistradoresRISC::new();
       
    // Atribuir aos registradores
    // Escolha quais registradores usar (por exemplo, x5 e x6 que são t0 e t1)
    regs.escrever(5, 6);  // t0 = primeiro valor
    regs.escrever(6, 5);  // t1 = segundo valor
    regs.escrever(7, 3);       // t2 = 3 (para shifts)
    regs.escrever(8, 0x1000);  // s0 = endereço base para memória
    regs.escrever(28, 1);      // t3 = 1 (para shift)
    regs.escrever(29, 10);     // t4 = 10 (para teste)
    // Mostrar estado dos registradores
    regs.mostrar_estado();
       
    // Demonstrar algumas instruções RISC-V
    println!("\n=== EXECUTANDO INSTRUÇÕES RISC-V ===");
    
    // =============================================
// TESTE DE INSTRUÇÕES DE SHIFT
// =============================================
println!("\n1. INSTRUÇÕES DE SHIFT:");
println!("------------------------");
instrucao_sll(&mut regs, 10, 5, 7);      // x10 = x5 << x7 (t0 << 3)
instrucao_slli(&mut regs, 11, 5, 2);     // x11 = x5 << 2 (t0 << 2)
instrucao_srl(&mut regs, 12, 6, 7);      // x12 = x6 >> x7 (t1 >> 3)
instrucao_srli(&mut regs, 13, 6, 1);     // x13 = x6 >> 1 (t1 >> 1)
instrucao_sra(&mut regs, 14, 5, 28);     // x14 = x5 >> x28 (t0 >> 1) com sinal
instrucao_srai(&mut regs, 15, 6, 2);     // x15 = x6 >> 2 (t1 >> 2) com sinal

// =============================================
// TESTE DE INSTRUÇÕES ARITMÉTICAS
// =============================================
println!("\n2. INSTRUÇÕES ARITMÉTICAS:");
println!("----------------------------");
instrucao_add(&mut regs, 16, 5, 6);      // x16 = x5 + x6 (t0 + t1)
instrucao_addi(&mut regs, 17, 5, 7);     // x17 = x5 + 7 (t0 + 7)
instrucao_sub(&mut regs, 18, 6, 5);      // x18 = x6 - x5 (t1 - t0)
instrucao_lui(&mut regs, 19, 0x12345);   // x19 = 0x12345 << 12
instrucao_auipc(&mut regs, 20, 1);       // x20 = PC + (1 << 12)

// =============================================
// TESTE DE INSTRUÇÕES LÓGICAS
// =============================================
println!("\n3. INSTRUÇÕES LÓGICAS:");
println!("----------------------");
instrucao_and(&mut regs, 21, 5, 6);      // x21 = x5 & x6 (t0 & t1)
instrucao_andi(&mut regs, 22, 5, 0xFF);  // x22 = x5 & 0xFF
instrucao_or(&mut regs, 23, 5, 6);       // x23 = x5 | x6 (t0 | t1)
instrucao_ori(&mut regs, 24, 5, 0x0F);   // x24 = x5 | 0x0F
instrucao_xor(&mut regs, 25, 5, 6);      // x25 = x5 ^ x6 (t0 ^ t1)
instrucao_xori(&mut regs, 26, 6, 0xAA);  // x26 = x6 ^ 0xAA

// =============================================
// TESTE DE INSTRUÇÕES DE COMPARAÇÃO
// =============================================
println!("\n4. INSTRUÇÕES DE COMPARAÇÃO:");
println!("-----------------------------");
instrucao_slt(&mut regs, 27, 5, 6);      // x27 = (x5 < x6) ? 1 : 0
instrucao_slti(&mut regs, 28, 5, 10);    // x28 = (x5 < 10) ? 1 : 0
instrucao_sltu(&mut regs, 29, 5, 6);     // x29 = (x5 < x6) unsigned? 1 : 0
instrucao_sltiu(&mut regs, 30, 6, 5);    // x30 = (x6 < 5) unsigned? 1 : 0

// Resetar PC para próximo grupo (pois branches alteram PC)
regs.pc = 0x0100;

// =============================================
// TESTE DE INSTRUÇÕES DE DESVIO (BRANCH)
// =============================================
println!("\n5. INSTRUÇÕES DE DESVIO (BRANCH):");
println!("-----------------------------------");
println!("PC inicial: 0x{:08X}", regs.pc);
instrucao_beq(&mut regs, 5, 5, 0x10);    // if x5 == x5, PC += 0x10
instrucao_bne(&mut regs, 5, 6, 0x10);    // if x5 != x6, PC += 0x10
instrucao_blt(&mut regs, 5, 6, 0x10);    // if x5 < x6, PC += 0x10
instrucao_bge(&mut regs, 6, 5, 0x10);    // if x6 >= x5, PC += 0x10
instrucao_bltu(&mut regs, 5, 6, 0x10);   // if x5 < x6 (unsigned), PC += 0x10
instrucao_bgeu(&mut regs, 6, 5, 0x10);   // if x6 >= x5 (unsigned), PC += 0x10

// Resetar PC para próximo grupo
regs.pc = 0x0200;

// =============================================
// TESTE DE INSTRUÇÕES DE SALTO (JUMP)
// =============================================
println!("\n6. INSTRUÇÕES DE SALTO (JUMP):");
println!("-------------------------------");
println!("PC inicial: 0x{:08X}", regs.pc);
instrucao_jal(&mut regs, 1, 0x20);       // x1 = PC+4, PC = PC + 0x20
println!("PC após JAL: 0x{:08X}", regs.pc);
regs.pc = 0x0300; // Reset para JALR
instrucao_jalr(&mut regs, 2, 8, 0x10);   // x2 = PC+4, PC = (x8 + 0x10) & ~1

// Resetar PC para próximo grupo
regs.pc = 0x0400;


// =============================================
// TESTE DE INSTRUÇÕES DE MEMÓRIA (LOAD/STORE)
// =============================================
println!("\n7. INSTRUÇÕES DE MEMÓRIA (LOAD/STORE):");
println!("----------------------------------------");

// Preparar dados na memória
let endereco_base = 0x1000;
let teste_dados = [0x12345678u32, 0x9ABCDEF0u32, 0x11111111u32, 0x22222222u32];
for (i, &dado) in teste_dados.iter().enumerate() {
    memoria.escrever(endereco_base + (i as u32 * 4), dado);
    println!("Mem[0x{:08X}] = 0x{:08X}", endereco_base + (i as u32 * 4), dado);
}

// Testar LOAD
instrucao_lw(&mut regs, 3, 8, 0,  memoria);      // x3 = Mem[x8 + 0]
instrucao_lh(&mut regs, 4, 8, 0,  memoria);      // x4 = Mem[x8 + 0] (half-word)
instrucao_lb(&mut regs, 5, 8, 0,  memoria);      // x5 = Mem[x8 + 0] (byte)
instrucao_lhu(&mut regs, 6, 8, 0, memoria);     // x6 = Mem[x8 + 0] (half-word unsigned)
instrucao_lbu(&mut regs, 7, 8, 0, memoria);     // x7 = Mem[x8 + 0] (byte unsigned)

// Testar STORE
instrucao_sw(&mut regs, 8, 10, 0x100, memoria);    // Mem[x8 + 0x100] = x10
instrucao_sh(&mut regs, 8, 11, 0x104, memoria);    // Mem[x8 + 0x104] = x11[15:0]
instrucao_sb(&mut regs, 8, 12, 0x108, memoria);    // Mem[x8 + 0x108] = x12[7:0]

// Verificar dados armazenados
println!("\nVerificando dados armazenados:");
println!("Mem[0x{:08X}] = 0x{:08X}", endereco_base + 0x100, memoria.ler(endereco_base + 0x100));
println!("Mem[0x{:08X}] = 0x{:08X}", endereco_base + 0x104, memoria.ler(endereco_base + 0x104));
println!("Mem[0x{:08X}] = 0x{:08X}", endereco_base + 0x108, memoria.ler(endereco_base + 0x108));

// Resetar PC para próximo grupo
regs.pc = 0x0500;

// =============================================
// TESTE DE INSTRUÇÕES DE SINCRONIZAÇÃO
// =============================================
println!("\n8. INSTRUÇÕES DE SINCRONIZAÇÃO:");
println!("---------------------------------");
instrucao_fence(&mut regs);
instrucao_fence_i(&mut regs);

// =============================================
// TESTE DE INSTRUÇÕES DE AMBIENTE
// =============================================
println!("\n9. INSTRUÇÕES DE AMBIENTE:");
println!("----------------------------");
instrucao_ecall(&mut regs);
instrucao_ebreak(&mut regs);

// =============================================
// MOSTRAR ESTADO FINAL DOS REGISTRADORES
// =============================================
println!("\n=== ESTADO FINAL DOS REGISTRADORES ===");
println!("PC: 0x{:08X}", regs.pc);
for i in 0..32 {
    let valor = regs.ler(i);
    if valor != 0 || i == 0 {  // Mostrar x0 e registradores não-zero
        let nome = match i {
            0 => "zero",
            1 => "ra",
            2 => "sp",
            3 => "gp",
            4 => "tp",
            5 => "t0",
            6 => "t1", 
            7 => "t2",
            8 => "s0/fp",
            9 => "s1",
            10 => "a0",
            11 => "a1",
            12 => "a2",
            13 => "a3",
            14 => "a4",
            15 => "a5",
            16 => "a6",
            17 => "a7",
            18 => "s2",
            19 => "s3",
            20 => "s4",
            21 => "s5",
            22 => "s6",
            23 => "s7",
            24 => "s8",
            25 => "s9",
            26 => "s10",
            27 => "s11",
            28 => "t3",
            29 => "t4",
            30 => "t5",
            31 => "t6",
            _ => "??",
        };
        println!("x{:2} ({:6}): 0x{:08X} ({})", i, nome, valor, valor as i32);
    }
}
}

struct MemoriaRAM {
    ram_principal: [u8; 0x80000],
    vram: [u8; 0x10000],
    area_reservada: [u8; 0xFC00],
    perifericos: [u8; 0x400],
}

impl MemoriaRAM {
    fn new() -> Self {
        MemoriaRAM {
            ram_principal: [EMPTY; 0x80000],
            vram: [EMPTY; 0x10000],
            area_reservada: [EMPTY; 0xFC00],
            perifericos: [EMPTY; 0x400],
        }
    }
    
    fn escrever(&mut self, endereco: u32, valor: u32) {
        let bytes = valor.to_be_bytes();
        
        match endereco {
            0x00000..=0x7FFFF => { //tamanho da memoria principal 524.288 bytes (512KB)
                let addr = endereco as usize;
                for i in 0..4 {
                    if addr + i < self.ram_principal.len() {
                        self.ram_principal[addr + i] = bytes[i];
                    }
                }
            },
            0x80000..=0x8FFFF => { //tamanho da VRAM 65.536 bytes (64KB)
                let addr = (endereco - 0x80000) as usize;
                for i in 0..4 {
                    if addr + i < self.vram.len() {
                        self.vram[addr + i] = bytes[i];
                    }
                }
            },
            0x90000..=0x9FBFF => { //tamanho area expansao 64.512 bytes (~63KB)
                let addr = (endereco - 0x90000) as usize;
                for i in 0..4 {
                    if addr + i < self.area_reservada.len() {
                        self.area_reservada[addr + i] = bytes[i];
                    }
                }
            },
            0x9FC00..=0x9FFFF => { //tamanho entrada/saida mapeada 1.024 bytes (1KB)
                let addr = (endereco - 0x9FC00) as usize;
                for i in 0..4 {
                    if addr + i < self.perifericos.len() {
                        self.perifericos[addr + i] = bytes[i];
                    }
                }
            },
            _ => println!("Endereço inválido: 0x{:08X}", endereco),
        }
    }
    
    fn ler(&self, endereco: u32) -> u32 {
        let mut bytes = [0u8; 4];
        
        match endereco {
            0x00000..=0x7FFFF => {
                let addr = endereco as usize;
                for i in 0..4 {
                    if addr + i < self.ram_principal.len() {
                        bytes[i] = self.ram_principal[addr + i];
                    }
                }
            },
            0x80000..=0x8FFFF => {
                let addr = (endereco - 0x80000) as usize;
                for i in 0..4 {
                    if addr + i < self.vram.len() {
                        bytes[i] = self.vram[addr + i];
                    }
                }
            },
            0x90000..=0x9FBFF => {
                let addr = (endereco - 0x90000) as usize;
                for i in 0..4 {
                    if addr + i < self.area_reservada.len() {
                        bytes[i] = self.area_reservada[addr + i];
                    }
                }
            },
            0x9FC00..=0x9FFFF => {
                let addr = (endereco - 0x9FC00) as usize;
                for i in 0..4 {
                    if addr + i < self.perifericos.len() {
                        bytes[i] = self.perifericos[addr + i];
                    }
                }
            },
            _ => {
                println!("Endereço inválido: 0x{:08X}", endereco);
                return 0;
            },
        }
        
        u32::from_be_bytes(bytes)
    }
    
    fn escrever_vram_byte(&mut self, endereco: u32, byte: u8) {
        if endereco >= 0x80000 && endereco <= 0x8FFFF {
            let addr = (endereco - 0x80000) as usize;
            if addr < self.vram.len() {
                self.vram[addr] = byte;
            }
        }
    }
    
    fn visualizar_vram(&self, endereco_inicial: u32, largura: usize, linhas: usize) {
        let mut addr = (endereco_inicial - 0x80000) as usize;
        
        for linha in 0..linhas {
            print!("VRAM[{:05X}]: ", endereco_inicial + (linha * largura) as u32);
            
            for coluna in 0..largura {
                if addr < self.vram.len() {
                    let byte = self.vram[addr];
                    let caractere = if byte >= 32 && byte <= 126 {
                        byte as char
                    } else {
                        ' '
                    };
                    print!("{}", caractere);
                    addr += 1;
                } else {
                    print!(" ");
                }
            }
            println!();
        }
    }
}

fn main() {
    Barramento();
}
