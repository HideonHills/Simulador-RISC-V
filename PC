fn main() {
    Memoria();
    CPU();
}

fn CPU() {
    println!("Valores iniciais: 5 e 10");
    println!("Binarios respectivamente: 101 e 1010");
   
    // Registradores RISC-V
    let zero: u32 = 0;      // x0 - sempre zero
    let mut ra: u32 = 0;    // x1 - return address
    let t0: u32 = 0b101;    // x5 - 5 em binário
    let t1: u32 = 0b1010;   // x6 - 10 em binário
    let t2: u32 = 0b11;     // x7
    let t3: u32 = 0b100;    // x28
    let t4: u32 = 0b101;    // x29
    let t5: u32 = 0b110;    // x30
    let t6: u32 = 0b111;    // x31
    let mut s1: u32;        // x9 - registrador para soma

    // Atribuição inicial
    s1 = t0 + t5;
   
    println!("\n--- OPERAÇÕES COM REGISTRADORES RISC-V ---");
   
    // Calcula todos os resultados
    let resultados = calcular_todos(t0, t1);
   
    // Mostra todos os resultados
    mostrar_resultados(resultados);
   
    // Mostra operação inicial com t0 e t5
    println!("\n--- OPERAÇÃO INICIAL ---");
    println!("t0 ({:b}) + t5 ({:b}) = s1 ({:b})", t0, t5, s1);
    println!("{} + {} = {}", t0, t5, s1);
}

const EMPTY: u8 = 0xFF;

fn Memoria() {    
    // Criando a memória RAM com mapeamento completo
    let mut memoria = MemoriaRAM::new();
    
    //memoria principal
    let test: u32 = 0b10101010101010101010101010101010;
    let end: u32 = 0x1000;

    // Escrevendo na RAM principal (programa/dados)
    memoria.escrever(end, test);
    println!("Escrito 0b{:032b} no endereço 0x{:05X}", test, end);
    
    // Lendo da RAM principal
    let valor_lido = memoria.ler(end);
    println!("Lido 0x{:08X} do endereço 0x{:05X}", valor_lido, end);

    // Escrevendo uma mensagem na VRAM
    let mensagem: &[u8; 8] = b"Bom dia!";
    for (i, &caractere) in mensagem.iter().enumerate() {
        memoria.escrever_vram_byte(0x80000 + i as u32 * 1, caractere);
    }
    
    
    // VISUALIZAÇÃO DA VRAM
    println!("\n=== VISUALIZAÇÃO DA VRAM ===");
    memoria.visualizar_vram(0x80000, 80, 6);
    
}

struct MemoriaRAM {
    ram_principal: [u8; 0x80000],
    vram: [u8; 0x10000],
    area_reservada: [u8; 0xFC00],
    perifericos: [u8; 0x400],
}

impl MemoriaRAM {
    fn new() -> Self {
        MemoriaRAM {
            ram_principal: [EMPTY; 0x80000],
            vram: [EMPTY; 0x10000],
            area_reservada: [EMPTY; 0xFC00],
            perifericos: [EMPTY; 0x400],
        }
    }
    
    fn escrever(&mut self, endereco: u32, valor: u32) {
        let bytes = valor.to_be_bytes();
        
        match endereco {
            0x00000..=0x7FFFF => { //tamanho da memoria principal 524.288 bytes (512KB)
                let addr = endereco as usize;
                for i in 0..4 {
                    if addr + i < self.ram_principal.len() {
                        self.ram_principal[addr + i] = bytes[i];
                    }
                }
            },
            0x80000..=0x8FFFF => { //tamanho da VRAM 65.536 bytes (64KB)
                let addr = (endereco - 0x80000) as usize;
                for i in 0..4 {
                    if addr + i < self.vram.len() {
                        self.vram[addr + i] = bytes[i];
                    }
                }
            },
            0x90000..=0x9FBFF => { //tamanho area expansao 64.512 bytes (~63KB)
                let addr = (endereco - 0x90000) as usize;
                for i in 0..4 {
                    if addr + i < self.area_reservada.len() {
                        self.area_reservada[addr + i] = bytes[i];
                    }
                }
            },
            0x9FC00..=0x9FFFF => { //tamanho entrada/saida mapeada 1.024 bytes (1KB)
                let addr = (endereco - 0x9FC00) as usize;
                for i in 0..4 {
                    if addr + i < self.perifericos.len() {
                        self.perifericos[addr + i] = bytes[i];
                    }
                }
            },
            _ => println!("Endereço inválido: 0x{:08X}", endereco),
        }
    }
    
    fn ler(&self, endereco: u32) -> u32 {
        let mut bytes = [0u8; 4];
        
        match endereco {
            0x00000..=0x7FFFF => {
                let addr = endereco as usize;
                for i in 0..4 {
                    if addr + i < self.ram_principal.len() {
                        bytes[i] = self.ram_principal[addr + i];
                    }
                }
            },
            0x80000..=0x8FFFF => {
                let addr = (endereco - 0x80000) as usize;
                for i in 0..4 {
                    if addr + i < self.vram.len() {
                        bytes[i] = self.vram[addr + i];
                    }
                }
            },
            0x90000..=0x9FBFF => {
                let addr = (endereco - 0x90000) as usize;
                for i in 0..4 {
                    if addr + i < self.area_reservada.len() {
                        bytes[i] = self.area_reservada[addr + i];
                    }
                }
            },
            0x9FC00..=0x9FFFF => {
                let addr = (endereco - 0x9FC00) as usize;
                for i in 0..4 {
                    if addr + i < self.perifericos.len() {
                        bytes[i] = self.perifericos[addr + i];
                    }
                }
            },
            _ => {
                println!("Endereço inválido: 0x{:08X}", endereco);
                return 0;
            },
        }
        
        u32::from_be_bytes(bytes)
    }
    
    fn escrever_vram_byte(&mut self, endereco: u32, byte: u8) {
        if endereco >= 0x80000 && endereco <= 0x8FFFF {
            let addr = (endereco - 0x80000) as usize;
            if addr < self.vram.len() {
                self.vram[addr] = byte;
            }
        }
    }
    
    fn visualizar_vram(&self, endereco_inicial: u32, largura: usize, linhas: usize) {
        let mut addr = (endereco_inicial - 0x80000) as usize;
        
        for linha in 0..linhas {
            print!("VRAM[{:05X}]: ", endereco_inicial + (linha * largura) as u32);
            
            for coluna in 0..largura {
                if addr < self.vram.len() {
                    let byte = self.vram[addr];
                    let caractere = if byte >= 32 && byte <= 126 {
                        byte as char
                    } else {
                        ' '
                    };
                    print!("{}", caractere);
                    addr += 1;
                } else {
                    print!(" ");
                }
            }
            println!();
        }
    }

}

struct Resultados {
    soma: u32,
    subtracao: u32,
    and: u32,
    or: u32,
    xor: u32,
}

fn calcular_todos(a: u32, b: u32) -> Resultados {
    let reg1 = a + b;
    let reg2 = b - a;
    let reg3 = a & b;
    let reg4 = a | b;
    let reg5 = a ^ b;
   
    println!("\n--- COMPARAÇÃO ---");
    if a < b {
        println!("{:b} (t0) < {:b} (t1)", a, b);
    } else if b < a {
        println!("{:b} (t1) < {:b} (t0)", b, a);
    } else {
        println!("{:b} (t0) = {:b} (t1)", a, b);
    }
   
    Resultados {
        soma: reg1,
        subtracao: reg2,
        and: reg3,
        or: reg4,
        xor: reg5,
    }
}

fn mostrar_resultados(resultados: Resultados) {
    println!("\n--- RESULTADOS DAS OPERAÇÕES ---");
   
    println!("ADD:  {:b} + {:b} = {:b} ({})",
        0b101, 0b1010, resultados.soma, resultados.soma);
   
    println!("SUB:  {:b} - {:b} = {:b} ({})",
        0b101, 0b1010, resultados.subtracao, resultados.subtracao);
   
    println!("AND:  {:b} & {:b} = {:b} ({})",
        0b101, 0b1010, resultados.and, resultados.and);
   
    println!("OR:   {:b} | {:b} = {:b} ({})",
        0b101, 0b1010, resultados.or, resultados.or);
   
    println!("XOR:  {:b} ^ {:b} = {:b} ({})",
        0b101, 0b1010, resultados.xor, resultados.xor);
}
