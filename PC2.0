use std::io;

#[derive(Debug, Clone, Copy)]
struct RegistradoresRISC {
    // Registradores principais conforme especificação RISC-V
    x0: u32,   // zero - sempre zero
    x1: u32,   // ra - return address
    x2: u32,   // sp - stack pointer
    x3: u32,   // gp - global pointer
    x4: u32,   // tp - thread pointer
    x5: u32,   // t0 - temporário 0
    x6: u32,   // t1 - temporário 1
    x7: u32,   // t2 - temporário 2
    x8: u32,   // s0/fp - saved/frame pointer
    x9: u32,   // s1 - saved 1
    x10: u32,  // a0 - argumento/retorno 0
    x11: u32,  // a1 - argumento/retorno 1
    x12: u32,  // a2 - argumento 2
    x13: u32,  // a3 - argumento 3
    x14: u32,  // a4 - argumento 4
    x15: u32,  // a5 - argumento 5
    x16: u32,  // a6 - argumento 6
    x17: u32,  // a7 - argumento 7
    x18: u32,  // s2 - saved 2
    x19: u32,  // s3 - saved 3
    x20: u32,  // s4 - saved 4
    x21: u32,  // s5 - saved 5
    x22: u32,  // s6 - saved 6
    x23: u32,  // s7 - saved 7
    x24: u32,  // s8 - saved 8
    x25: u32,  // s9 - saved 9
    x26: u32,  // s10 - saved 10
    x27: u32,  // s11 - saved 11
    x28: u32,  // t3 - temporário 3
    x29: u32,  // t4 - temporário 4
    x30: u32,  // t5 - temporário 5
    x31: u32,  // t6 - temporário 6
    pc: u32,   // Program Counter
}

impl RegistradoresRISC {
    fn new() -> Self {
        RegistradoresRISC {
            x0: 0,
            x1: 0,
            x2: 0,
            x3: 0,
            x4: 0,
            x5: 0,
            x6: 0,
            x7: 0,
            x8: 0,
            x9: 0,
            x10: 0,
            x11: 0,
            x12: 0,
            x13: 0,
            x14: 0,
            x15: 0,
            x16: 0,
            x17: 0,
            x18: 0,
            x19: 0,
            x20: 0,
            x21: 0,
            x22: 0,
            x23: 0,
            x24: 0,
            x25: 0,
            x26: 0,
            x27: 0,
            x28: 0,
            x29: 0,
            x30: 0,
            x31: 0,
            pc: 0,
        }
    }

    fn ler(&self, numero_reg: usize) -> u32 {
        match numero_reg {
            0 => self.x0,
            1 => self.x1,
            2 => self.x2,
            3 => self.x3,
            4 => self.x4,
            5 => self.x5,
            6 => self.x6,
            7 => self.x7,
            8 => self.x8,
            9 => self.x9,
            10 => self.x10,
            11 => self.x11,
            12 => self.x12,
            13 => self.x13,
            14 => self.x14,
            15 => self.x15,
            16 => self.x16,
            17 => self.x17,
            18 => self.x18,
            19 => self.x19,
            20 => self.x20,
            21 => self.x21,
            22 => self.x22,
            23 => self.x23,
            24 => self.x24,
            25 => self.x25,
            26 => self.x26,
            27 => self.x27,
            28 => self.x28,
            29 => self.x29,
            30 => self.x30,
            31 => self.x31,
            _ => 0,
        }
    }

    fn escrever(&mut self, numero_reg: usize, valor: u32) {
        if numero_reg != 0 {
            match numero_reg {
                1 => self.x1 = valor,
                2 => self.x2 = valor,
                3 => self.x3 = valor,
                4 => self.x4 = valor,
                5 => self.x5 = valor,
                6 => self.x6 = valor,
                7 => self.x7 = valor,
                8 => self.x8 = valor,
                9 => self.x9 = valor,
                10 => self.x10 = valor,
                11 => self.x11 = valor,
                12 => self.x12 = valor,
                13 => self.x13 = valor,
                14 => self.x14 = valor,
                15 => self.x15 = valor,
                16 => self.x16 = valor,
                17 => self.x17 = valor,
                18 => self.x18 = valor,
                19 => self.x19 = valor,
                20 => self.x20 = valor,
                21 => self.x21 = valor,
                22 => self.x22 = valor,
                23 => self.x23 = valor,
                24 => self.x24 = valor,
                25 => self.x25 = valor,
                26 => self.x26 = valor,
                27 => self.x27 = valor,
                28 => self.x28 = valor,
                29 => self.x29 = valor,
                30 => self.x30 = valor,
                31 => self.x31 = valor,
                _ => {},
            }
        }
    }

    fn mostrar_estado(&self) {
        println!("\n=== ESTADO DOS REGISTRADORES RISC-V ===");
        println!("PC: 0x{:08X}", self.pc);
        println!("x0 (zero): 0x{:08X} ({})", self.x0, self.x0);
        println!("x1 (ra):   0x{:08X} ({})", self.x1, self.x1);
        println!("x5 (t0):   0x{:08X} ({}) - bin: {:b}", self.x5, self.x5, self.x5);
        println!("x6 (t1):   0x{:08X} ({}) - bin: {:b}", self.x6, self.x6, self.x6);
        println!("x7 (t2):   0x{:08X} ({}) - bin: {:b}", self.x7, self.x7, self.x7);
        println!("x9 (s1):   0x{:08X} ({}) - bin: {:b}", self.x9, self.x9, self.x9);
        println!("x28 (t3):  0x{:08X} ({}) - bin: {:b}", self.x28, self.x28, self.x28);
        println!("x29 (t4):  0x{:08X} ({}) - bin: {:b}", self.x29, self.x29, self.x29);
        println!("x30 (t5):  0x{:08X} ({}) - bin: {:b}", self.x30, self.x30, self.x30);
        println!("x31 (t6):  0x{:08X} ({}) - bin: {:b}", self.x31, self.x31, self.x31);
    }
}

// =============================================
// FUNÇÕES DA ISA RISC-V RV32I
// =============================================

fn instrucao_add(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, rs2: usize) {
    let valor1 = regs.ler(rs1);
    let valor2 = regs.ler(rs2);
    let resultado = valor1.wrapping_add(valor2);
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("ADD: x{} = x{} ({}) + x{} ({}) = {}", 
             rd, rs1, valor1, rs2, valor2, resultado);
}

fn instrucao_sub(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, rs2: usize) {
    let valor1 = regs.ler(rs1);
    let valor2 = regs.ler(rs2);
    let resultado = valor1.wrapping_sub(valor2);
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("SUB: x{} = x{} ({}) - x{} ({}) = {}", 
             rd, rs1, valor1, rs2, valor2, resultado);
}

fn instrucao_and(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, rs2: usize) {
    let valor1 = regs.ler(rs1);
    let valor2 = regs.ler(rs2);
    let resultado = valor1 & valor2;
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("AND: x{} = x{} ({:b}) & x{} ({:b}) = {:b}", 
             rd, rs1, valor1, rs2, valor2, resultado);
}

fn instrucao_or(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, rs2: usize) {
    let valor1 = regs.ler(rs1);
    let valor2 = regs.ler(rs2);
    let resultado = valor1 | valor2;
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("OR:  x{} = x{} ({:b}) | x{} ({:b}) = {:b}", 
             rd, rs1, valor1, rs2, valor2, resultado);
}

fn instrucao_xor(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, rs2: usize) {
    let valor1 = regs.ler(rs1);
    let valor2 = regs.ler(rs2);
    let resultado = valor1 ^ valor2;
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("XOR: x{} = x{} ({:b}) ^ x{} ({:b}) = {:b}", 
             rd, rs1, valor1, rs2, valor2, resultado);
}

fn instrucao_addi(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, imediato: i32) {
    let valor1 = regs.ler(rs1);
    let resultado = valor1.wrapping_add(imediato as u32);
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("ADDI: x{} = x{} ({}) + {} = {}", 
             rd, rs1, valor1, imediato, resultado);
}

fn instrucao_slt(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, rs2: usize) {
    let valor1 = regs.ler(rs1) as i32;
    let valor2 = regs.ler(rs2) as i32;
    let resultado = if valor1 < valor2 { 1 } else { 0 };
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("SLT: x{} = (x{} ({}) < x{} ({})) ? 1 : 0 = {}", 
             rd, rs1, valor1, rs2, valor2, resultado);
}

fn instrucao_sll(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, rs2: usize) {
    let valor1 = regs.ler(rs1);
    let valor2 = regs.ler(rs2);
    let shamt = valor2 & 0x1F; // Apenas 5 bits menos significativos
    let resultado = valor1 << shamt;
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("SLL: x{} = x{} ({:b}) << {} = {:b}", 
             rd, rs1, valor1, shamt, resultado);
}

fn instrucao_srl(regs: &mut RegistradoresRISC, rd: usize, rs1: usize, rs2: usize) {
    let valor1 = regs.ler(rs1);
    let valor2 = regs.ler(rs2);
    let shamt = valor2 & 0x1F;
    let resultado = valor1 >> shamt;
    regs.escrever(rd, resultado);
    regs.pc = regs.pc.wrapping_add(4);
    println!("SRL: x{} = x{} ({:b}) >> {} = {:b}", 
             rd, rs1, valor1, shamt, resultado);
}

const EMPTY: u8 = 0xFF;

fn Barramento() {
    Memoria();
    CPU();
}

fn CPU() {
       
    // Criar estrutura de registradores RISC-V
    let mut regs = RegistradoresRISC::new();
    
   let mut entrada1 = String::new();
    println!("Insira o primeiro valor (decimal):");
    io::stdin()
        .read_line(&mut entrada1)
        .expect("Falha ao ler a entrada");
    
    // Segundo valor  
    let mut entrada2 = String::new();
    println!("Insira o segundo valor (decimal):");
    io::stdin()
        .read_line(&mut entrada2)
        .expect("Falha ao ler a entrada");
    
    // Converter para números inteiros
    let numero1: i32 = entrada1 
        .trim() 
        .parse()
        .expect("Por favor, digite um número inteiro válido!");
    let numero2: i32 = entrada2 
        .trim() 
        .parse()
        .expect("Por favor, digite um número inteiro válido!");
    
    // Converter para binário (como string para exibição)
    let binario1_str = format!("{:b}", numero1);
    let binario2_str = format!("{:b}", numero2);
    
    // Converter para u32 para os registradores
    let valor1 = if numero1 >= 0 {
        numero1 as u32
    } else {
        // Para números negativos, usar complemento de 2
        (0xFFFFFFFFu32).wrapping_sub((-numero1) as u32 - 1)
    };
    
    let valor2 = if numero2 >= 0 {
        numero2 as u32
    } else {
        (0xFFFFFFFFu32).wrapping_sub((-numero2) as u32 - 1)
    };
    
    // Atribuir aos registradores
    // Escolha quais registradores usar (por exemplo, x5 e x6 que são t0 e t1)
    regs.escrever(5, valor1);  // t0 = primeiro valor
    regs.escrever(6, valor2);  // t1 = segundo valor

    // Mostrar estado dos registradores
    regs.mostrar_estado();
       
    // Demonstrar algumas instruções RISC-V
    println!("\n=== EXECUTANDO INSTRUÇÕES RISC-V ===");
    
    // Teste de instruções
    instrucao_add(&mut regs, 10, 5, 6);      // a0 = t0 + t1
    instrucao_sub(&mut regs, 11, 6, 5);      // a1 = t1 - t0
    instrucao_and(&mut regs, 12, 5, 6);      // a2 = t0 & t1
    instrucao_or(&mut regs, 13, 5, 6);       // a3 = t0 | t1
    instrucao_xor(&mut regs, 14, 5, 6);      // a4 = t0 ^ t1
    instrucao_addi(&mut regs, 15, 5, 7);     // a5 = t0 + 7
    instrucao_slt(&mut regs, 16, 5, 6);      // a6 = (t0 < t1) ? 1 : 0
    instrucao_sll(&mut regs, 17, 5, 7);      // a7 = t0 << t2
    instrucao_srl(&mut regs, 18, 6, 28);     // s2 = t1 >> t3
    
    // Mostrar estado final
    println!("\n=== ESTADO FINAL DOS REGISTRADORES ===");
    println!("PC: 0x{:08X}", regs.pc);
    for i in 10..=18 {
        println!("x{}: 0x{:08X} ({})", i, regs.ler(i), regs.ler(i));
    }
}

fn Memoria() {    
    // Criando a memória RAM com mapeamento completo
    let mut memoria = MemoriaRAM::new();
    
    //memoria principal
    let test: u32 = 0b10101010101010101010101010101010;
    let end: u32 = 0x1000;

    // Escrevendo na RAM principal (programa/dados)
    memoria.escrever(end, test);
    println!("Escrito 0b{:032b} no endereço 0x{:05X}", test, end);
    
    // Lendo da RAM principal
    let valor_lido = memoria.ler(end);
    println!("Lido 0x{:08X} do endereço 0x{:05X}", valor_lido, end);

    // Escrevendo uma mensagem na VRAM
    let mensagem: &[u8; 8] = b"Bom dia!";
    for (i, &caractere) in mensagem.iter().enumerate() {
        memoria.escrever_vram_byte(0x80000 + i as u32 * 1, caractere);
    }
    
    // VISUALIZAÇÃO DA VRAM
    println!("\n=== VISUALIZAÇÃO DA VRAM ===");
    memoria.visualizar_vram(0x80000, 80, 6);
}

struct MemoriaRAM {
    ram_principal: [u8; 0x80000],
    vram: [u8; 0x10000],
    area_reservada: [u8; 0xFC00],
    perifericos: [u8; 0x400],
}

impl MemoriaRAM {
    fn new() -> Self {
        MemoriaRAM {
            ram_principal: [EMPTY; 0x80000],
            vram: [EMPTY; 0x10000],
            area_reservada: [EMPTY; 0xFC00],
            perifericos: [EMPTY; 0x400],
        }
    }
    
    fn escrever(&mut self, endereco: u32, valor: u32) {
        let bytes = valor.to_be_bytes();
        
        match endereco {
            0x00000..=0x7FFFF => { //tamanho da memoria principal 524.288 bytes (512KB)
                let addr = endereco as usize;
                for i in 0..4 {
                    if addr + i < self.ram_principal.len() {
                        self.ram_principal[addr + i] = bytes[i];
                    }
                }
            },
            0x80000..=0x8FFFF => { //tamanho da VRAM 65.536 bytes (64KB)
                let addr = (endereco - 0x80000) as usize;
                for i in 0..4 {
                    if addr + i < self.vram.len() {
                        self.vram[addr + i] = bytes[i];
                    }
                }
            },
            0x90000..=0x9FBFF => { //tamanho area expansao 64.512 bytes (~63KB)
                let addr = (endereco - 0x90000) as usize;
                for i in 0..4 {
                    if addr + i < self.area_reservada.len() {
                        self.area_reservada[addr + i] = bytes[i];
                    }
                }
            },
            0x9FC00..=0x9FFFF => { //tamanho entrada/saida mapeada 1.024 bytes (1KB)
                let addr = (endereco - 0x9FC00) as usize;
                for i in 0..4 {
                    if addr + i < self.perifericos.len() {
                        self.perifericos[addr + i] = bytes[i];
                    }
                }
            },
            _ => println!("Endereço inválido: 0x{:08X}", endereco),
        }
    }
    
    fn ler(&self, endereco: u32) -> u32 {
        let mut bytes = [0u8; 4];
        
        match endereco {
            0x00000..=0x7FFFF => {
                let addr = endereco as usize;
                for i in 0..4 {
                    if addr + i < self.ram_principal.len() {
                        bytes[i] = self.ram_principal[addr + i];
                    }
                }
            },
            0x80000..=0x8FFFF => {
                let addr = (endereco - 0x80000) as usize;
                for i in 0..4 {
                    if addr + i < self.vram.len() {
                        bytes[i] = self.vram[addr + i];
                    }
                }
            },
            0x90000..=0x9FBFF => {
                let addr = (endereco - 0x90000) as usize;
                for i in 0..4 {
                    if addr + i < self.area_reservada.len() {
                        bytes[i] = self.area_reservada[addr + i];
                    }
                }
            },
            0x9FC00..=0x9FFFF => {
                let addr = (endereco - 0x9FC00) as usize;
                for i in 0..4 {
                    if addr + i < self.perifericos.len() {
                        bytes[i] = self.perifericos[addr + i];
                    }
                }
            },
            _ => {
                println!("Endereço inválido: 0x{:08X}", endereco);
                return 0;
            },
        }
        
        u32::from_be_bytes(bytes)
    }
    
    fn escrever_vram_byte(&mut self, endereco: u32, byte: u8) {
        if endereco >= 0x80000 && endereco <= 0x8FFFF {
            let addr = (endereco - 0x80000) as usize;
            if addr < self.vram.len() {
                self.vram[addr] = byte;
            }
        }
    }
    
    fn visualizar_vram(&self, endereco_inicial: u32, largura: usize, linhas: usize) {
        let mut addr = (endereco_inicial - 0x80000) as usize;
        
        for linha in 0..linhas {
            print!("VRAM[{:05X}]: ", endereco_inicial + (linha * largura) as u32);
            
            for coluna in 0..largura {
                if addr < self.vram.len() {
                    let byte = self.vram[addr];
                    let caractere = if byte >= 32 && byte <= 126 {
                        byte as char
                    } else {
                        ' '
                    };
                    print!("{}", caractere);
                    addr += 1;
                } else {
                    print!(" ");
                }
            }
            println!();
        }
    }
}

fn main() {
    Barramento();
}
